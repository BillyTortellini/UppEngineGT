#ifndef __TEXTURE_HPP__
#define __TEXTURE_HPP__

#include "renderer.hpp"
#include "stb_image.h"

// -------------------
// --- TextureData ---
// -------------------
struct TextureData
{
    int width;
    int height;
    int numChannels; // Determines if R, RG, RGB or RGBA data is represented
    byte* data;    
    Blk blk;
    Allocator* alloc;
};

void init(TextureData* textureData, const char* filename, Allocator* alloc) 
{
    textureData->alloc = alloc;
    TmpStr filepath = "ressources/textures/";
    filepath = filepath + filename;

    // Load image
    stbi_set_flip_vertically_on_load(true);
    byte* data = stbi_load((char*)filepath, &textureData->width, &textureData->height, &textureData->numChannels, 0);
    assert(data != nullptr, "stbi_load failed\n");
    SCOPE_EXIT(stbi_image_free(data););

    // Copy data to renderAlloc
    u64 size = textureData->numChannels * textureData->width * textureData->height;
    textureData->blk = alloc->alloc(textureData->numChannels * textureData->width * textureData->height);
    memcpy(textureData->blk.data, data, size);
    textureData->data = (byte*) textureData->blk.data;
}

void shutdown(TextureData* textureData) {
    textureData->alloc->dealloc(textureData->blk);
}



// ---------------
// --- Texture ---
// ---------------
struct TextureFilterMode
{
    TextureFilterMode(){};
    TextureFilterMode(GLint min, GLint mag, GLint u, GLint v) 
        : minFilter(min), magFilter(mag), wrapU(u), wrapV(v) {}

    GLint minFilter;
    GLint magFilter;
    GLint wrapU;
    GLint wrapV;
};

bool equals(const TextureFilterMode& m1, const TextureFilterMode& m2) {
    return m1.minFilter == m2.minFilter &&
        m1.magFilter == m2.magFilter &&
        m1.wrapU == m2.wrapU &&
        m1.wrapV == m2.wrapV;
}

struct Texture
{
    GLuint id;
    int width; 
    int height;
    GLint internalFormat; // GL_RED, GL_RGB, GL_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL 
    GLenum format; // Format of cpu(RAM) data
    TextureFilterMode filterMode;
    GLenum samplerType;
    bool mipmapped;
};

GLint bind(Texture* texture) {
    return bindTexture2D(texture->id); 
}

void setFilterMode(Texture* tex, const TextureFilterMode& mode)
{
    if (equals(tex->filterMode, mode)) return;

    bind(tex); 
    tex->filterMode = mode;
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, mode.minFilter);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, mode.magFilter);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, mode.wrapU);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, mode.wrapV);
    if (!tex->mipmapped && 
            (mode.minFilter == GL_LINEAR_MIPMAP_LINEAR || 
             mode.minFilter == GL_NEAREST_MIPMAP_LINEAR ||
             mode.minFilter == GL_LINEAR_MIPMAP_NEAREST || 
             mode.minFilter == GL_NEAREST_MIPMAP_NEAREST)) {
        glGenerateMipmap(GL_TEXTURE_2D);
        tex->mipmapped = true;
    }
}

// Multiple ways exist to create a texture:
//  1. Initialize it with TextureData (May be generated by the cpu)
//  2. Call with a filename, which loads the texture from ressources/textures/
//  3. Call with just width height and format, which initializes an empty texture (E.g. for framebuffers)

// Calls with texData
void init(Texture* tex, TextureData* texData, const TextureFilterMode& filterMode) 
{
    tex->width= texData->width;
    tex->height= texData->height;
    tex->mipmapped = false;

    // Determine format
    GLenum format = GL_RED;
    GLint internalFormat = GL_RED;
    switch(texData->numChannels) 
    {
        case 1:
            format = GL_RED;
            internalFormat = GL_RED;
            break;
        case 2:
            format = GL_RG;
            internalFormat = GL_RG;
            break;
        case 3:
            format = GL_RGB;
            internalFormat = GL_RGB;
            break;
        case 4:
            format = GL_RGBA;
            internalFormat = GL_RGBA;
            break;
        default:
            invalid_path("Num channels not valid!\n");
            break;
    }
    tex->internalFormat = internalFormat;
    tex->format = format;
    tex->samplerType = GL_SAMPLER_2D;

    // Generate texture
    glGenTextures(1, &tex->id);
    assert(tex->id != 0, "glGenTextures failed!\n");
    bindTexture2D(tex->id);

    // Set image data
    glTexImage2D(GL_TEXTURE_2D, 0, 
            internalFormat,
            texData->width, texData->height, 
            0,// Always 0
            format, 
            GL_UNSIGNED_BYTE, 
            texData->data);

    // Set filter mode
    setFilterMode(tex, filterMode); 
}

void init(Texture* tex, TextureData* texData) {
    init(tex, texData, TextureFilterMode(GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR, GL_REPEAT, GL_REPEAT));
}

// Calls with filename
void init(Texture* texture, const char* filepath, const TextureFilterMode& filterMode, Allocator* alloc) 
{
    // Load image from filepath
    TextureData tmpTexData;
    init(&tmpTexData, filepath, alloc);
    SCOPE_EXIT(shutdown(&tmpTexData););

    // Create texture
    init(texture, &tmpTexData, filterMode);
}

void init(Texture* texture, const char* name, Allocator* alloc) 
{
    init(texture, name,
        TextureFilterMode(GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR, GL_REPEAT, GL_REPEAT),
        alloc); 
}

// Calls with width and height (Initializes empty texture)
void init(Texture* tex, int width, int height, GLenum internalFormat, const TextureFilterMode& filterMode)
{
    // Set members
    tex->width = width;
    tex->height = height;
    tex->mipmapped = false;
    tex->internalFormat = internalFormat;

    // Set sampler type
    GLenum format = GL_RGBA;
    switch (tex->internalFormat)
    {
        // Fall-through
        case GL_R:
        case GL_RG:
        case GL_RGB:
        case GL_RGBA:
        case GL_R16F:
        case GL_RG16F:
        case GL_RGB16F:
        case GL_RGBA16F:
        case GL_R32F:
        case GL_RG32F:
        case GL_RGB32F:
        case GL_RGBA32F:
            format = GL_RGBA;
            break;
        case GL_DEPTH_COMPONENT:
            format = GL_DEPTH_COMPONENT;
            break;
        case GL_DEPTH_STENCIL:
            format = GL_DEPTH_STENCIL;
            break;
        default:
            invalid_path("Internal format not supported!\n");
    }
    tex->samplerType = GL_SAMPLER_2D;
    tex->format = format;

    // Generate texture
    glGenTextures(1, &tex->id);
    assert(tex->id != 0, "glGenTextures failed!\n");
    bindTexture2D(tex->id);

    // Generate image GPU storage
    glTexImage2D(GL_TEXTURE_2D, 0, 
            internalFormat,
            tex->width, tex->height, 
            0,// Always 0
            format, 
            GL_UNSIGNED_BYTE, 
            NULL);

    setFilterMode(tex, filterMode); 
}

void resize(Texture* texture, int width, int height) 
{
    bindTexture2D(texture->id);
    texture->width = width;
    texture->height = height;

    // Generate image GPU storage
    glTexImage2D(GL_TEXTURE_2D, 0, 
            texture->internalFormat,
            texture->width, texture->height, 
            0,// Always 0
            texture->format, 
            GL_UNSIGNED_BYTE, 
            NULL);

    texture->mipmapped = false;
    setFilterMode(texture, texture->filterMode); // Redo filter mode (Maybe regenerate mipmap)
}

void shutdown(Texture* tex) {
    glDeleteTextures(1, &tex->id);
}

void setUniform(ShaderProgram* p, const char* name, Texture* t)
{
    bindProgram(p->id); 
    UniformInfo* info = getUniformInfo(p, name); 
    if (info == nullptr) { 
        return; 
    } 
    if (info->type != t->samplerType) { 
        loggf("Uniform \"%s\" type did not match\n", name); 
        return; 
    } 
    glUniform1i(info->location, bind(t)); 
}

void setUniform(AutoShaderProgram* p, const char* name, Texture* t) {
    setUniform(&p->program, name, t);
}


#endif
